// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	dcos "github.com/dcos/client-go/dcos"
	cosmos "github.com/dcos/dcos-core-cli/pkg/cosmos"

	mock "github.com/stretchr/testify/mock"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

// PackageAddRepo provides a mock function with given fields: name, uri, index
func (_m *Client) PackageAddRepo(name string, uri string, index *int) ([]dcos.CosmosPackageRepo, error) {
	ret := _m.Called(name, uri, index)

	var r0 []dcos.CosmosPackageRepo
	if rf, ok := ret.Get(0).(func(string, string, *int) []dcos.CosmosPackageRepo); ok {
		r0 = rf(name, uri, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dcos.CosmosPackageRepo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, *int) error); ok {
		r1 = rf(name, uri, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PackageDeleteRepo provides a mock function with given fields: name
func (_m *Client) PackageDeleteRepo(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PackageDescribe provides a mock function with given fields: name, version
func (_m *Client) PackageDescribe(name string, version string) (*cosmos.Description, error) {
	ret := _m.Called(name, version)

	var r0 *cosmos.Description
	if rf, ok := ret.Get(0).(func(string, string) *cosmos.Description); ok {
		r0 = rf(name, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cosmos.Description)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(name, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PackageInstall provides a mock function with given fields: appID, name, version, optionsPath
func (_m *Client) PackageInstall(appID string, name string, version string, optionsPath string) error {
	ret := _m.Called(appID, name, version, optionsPath)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(appID, name, version, optionsPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PackageList provides a mock function with given fields:
func (_m *Client) PackageList() ([]cosmos.Package, error) {
	ret := _m.Called()

	var r0 []cosmos.Package
	if rf, ok := ret.Get(0).(func() []cosmos.Package); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cosmos.Package)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PackageListRepo provides a mock function with given fields:
func (_m *Client) PackageListRepo() (*dcos.CosmosPackageListRepoV1Response, error) {
	ret := _m.Called()

	var r0 *dcos.CosmosPackageListRepoV1Response
	if rf, ok := ret.Get(0).(func() *dcos.CosmosPackageListRepoV1Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dcos.CosmosPackageListRepoV1Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PackageListVersions provides a mock function with given fields: name
func (_m *Client) PackageListVersions(name string) ([]string, error) {
	ret := _m.Called(name)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PackageRender provides a mock function with given fields: appID, name, version, optionsPath
func (_m *Client) PackageRender(appID string, name string, version string, optionsPath string) (map[string]interface{}, error) {
	ret := _m.Called(appID, name, version, optionsPath)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, string) map[string]interface{}); ok {
		r0 = rf(appID, name, version, optionsPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(appID, name, version, optionsPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PackageSearch provides a mock function with given fields: query
func (_m *Client) PackageSearch(query string) (*cosmos.SearchResult, error) {
	ret := _m.Called(query)

	var r0 *cosmos.SearchResult
	if rf, ok := ret.Get(0).(func(string) *cosmos.SearchResult); ok {
		r0 = rf(query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cosmos.SearchResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PackageUninstall provides a mock function with given fields: packageName, all, appID
func (_m *Client) PackageUninstall(packageName string, all bool, appID string) (*dcos.CosmosPackageUninstallV1Response, error) {
	ret := _m.Called(packageName, all, appID)

	var r0 *dcos.CosmosPackageUninstallV1Response
	if rf, ok := ret.Get(0).(func(string, bool, string) *dcos.CosmosPackageUninstallV1Response); ok {
		r0 = rf(packageName, all, appID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dcos.CosmosPackageUninstallV1Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, bool, string) error); ok {
		r1 = rf(packageName, all, appID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
